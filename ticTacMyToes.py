# -*- coding: utf-8 -*-
"""tictactoe.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v4Mg4JddNzohxFCO2Ddf8pZcvLN-Z3WG
"""

import enum 

class Player(enum.Enum):
  x = 1
  o = 2

  @property
  def other(self):
    return Player.x if self == Player.o else Player.o

import copy


MARKER_TO_CHAR = {
    None:' . ',
    Player.x:' x ',
    Player.o:' o ',
}


class Board():
  def __init__(self):
    self.dimension = 3
    self.grid = [[None for y in range(self.dimension)] for  x in range(self.dimension)]
    self.moves = []
    

  def print(self):
      print()
      for row in range(self.dimension):
        line = []
        for col in range(self.dimension):
          line.append(MARKER_TO_CHAR[self.grid[row][col]])
        print('%s' % (''.join(line)))
  
  def check_col(self):
      for col in range(self.dimension):
        cols = set()
        for row in range(self.dimension):
          cols.add(self.grid[row][col])
        if len(cols) == 1:
          val = cols.pop()
          if val != None:
            return val
      return None
  
  
  def check_row(self):
    for row in range(3):
      r = set(self.grid[row])
      if len(r) == 1:
        val = r.pop()
        if val != None:
          return val
    return None

  def check_diagf(self):
    diag = set([ self.grid[i][i] for i in range(self.dimension)])
    if len(diag)== 1:
      val = diag.pop()
      if val != None:
        return val
    return None


  def check_diagb(self):
    backwards_diag = set()
    backwards_diag.add(self.grid[0][2])
    backwards_diag.add(self.grid[1][1])
    backwards_diag.add(self.grid[0][2])
    if (len(backwards_diag) == 1):
        value = backwards_diag.pop()
        if (value != None):
          return value
    return None

  
  def has_winner(self):
      if len(self.moves) < 5:
          return None
      row = self.check_row()
      col = self.check_col()
      front_diag = self.check_diagf()
      backwards_diag = self.check_diagb()

      if row:
        return row
      if col:
        return col
      if front_diag:
        return front_diag
      if backwards_diag:
        return backwards_diag
  
      
     
      #diagonal time
      return None

  def make_move(self, row, col, player):
        if (self.is_space_empty(row, col)):
            self.grid[row][col] = player
            self.moves.append([row,col])
        else:
            raise Exception("Attempting to move onto already occupied space")

  def last_move(self):
        return self.moves[-1]

  def is_space_empty(self, row, col):
        return self.grid[row][col] is None

  def get_legal_moves(self):
        choices = []
        for row in range(self.dimension):
            for col in range(self.dimension):
                if (self.is_space_empty(row, col)):
                    choices.append([row,col])
        return choices
                
  def __deepcopy__(self, memodict={}):
        dp = Board()
        dp.grid = copy.deepcopy(self.grid) 
        dp.moves = copy.deepcopy(self.moves)
        return dp  
  
  def column(self,grid, i):
        return [row[i] for row in self.grid]

class Game():
    def __init__(self, num_of_games):
        self.num_of_games = num_of_games
        self.x_wins = 0
        self.o_wins = 0
        self.ties = 0
    
    def sim(self, xbot, obot, print_game = False):
        for _ in range(self.num_of_games):
            board = Board()
            current_turn = Player.x
            winner = None
            for i in range(9):
                choice = []
                if (current_turn == xbot.player):
                    choice = xbot.select_move(board)
                else:
                    choice = obot.select_move(board)
                board.make_move(choice[0], choice[1], current_turn)

                winner = board.has_winner()

                if print_game:
                    board.print()
                if (winner != None):
                    print ("Congrats " + str(winner))
                    break
                elif (i == 8):
                    print ("It's a tie!")
                    break
                current_turn = current_turn.other
            if (winner == Player.x):
                self.x_wins = self.x_wins + 1
            elif (winner == Player.o):
                self.o_wins = self.o_wins + 1
            else:
                self.ties = self.ties + 1
        
        print ("x wins: " + str(self.x_wins))
        print ("o wins: " + str(self.o_wins))
        print ("ties: " + str(self.ties))

import random

class RandomBot():
    def __init__(self,player):
      self.player = player

    def select_move(self, board):
      candidates = board.get_legal_moves()
      return random.choice(candidates)



class Choice():

  def __init__(self, move, value, depth):
      self.move = move
      self.value = value
      self.depth = depth


class MinimaxBot():

  def __init__(self,player):
    self.player = player

  def minimax(self, board, cur_player, maximize, depth):
      winner = board.has_winner()
      if winner == self.player:
        return Choice(board.last_move(), 10 - depth, depth)#punishment for going tooooooo low
      elif winner == self.player.other:
        return Choice(board.last_move(), -10 + depth, depth) 
      elif len(board.moves ) == 9:
        return Choice(board.last_move(), 0, depth)


      results = [] 
      moves = board.get_legal_moves()
      for m in moves:
        new_board = copy.deepcopy(board)
        new_board.make_move(m[0],m[1],cur_player)
        res = self.minimax(new_board, cur_player.other, not maximize, depth + 1)
       
        res.move = new_board.last_move()
        results.append(res)

      max_choice = None
      max_val = -100
      min_choice = None
      min_val = 100

      for res in results:
        if res.value < min_val:
          min_choice = res
          min_choice.value  = res.value
        
        if res.value > max_val:
          max_choice = res
          max_choice.value = res.value

      if not maximize:
        return min_choice
      
      if maximize:
        return max_choice

      
  def select_move(self, board):
    depth = 0
    maximize = True
    choice = self.minimax(board,self.player, maximize, depth)
    return choice.move

def main():
  
  xbot = MinimaxBot(Player.x)
  obot = RandomBot(Player.o)
  game = Game(8)
  
  game.sim(xbot,obot,True)

if __name__ == '__main__':
  main()